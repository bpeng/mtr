// Code generated by protoc-gen-go.
// source: data.proto
// DO NOT EDIT!

package mtrpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// DataLatencySummary is a summary of data latency metrics for each site.
// mean should not be 0.  fifty and ninety may be unknown (0).
// If upper == lower == 0 then no threshold has been set on the metric.
type DataLatencySummary struct {
	// The siteID for the metric e.g., TAUP
	SiteID string `protobuf:"bytes,1,opt,name=site_iD" json:"site_iD,omitempty"`
	// The typeID for the metric e.g., latency.strong
	TypeID string `protobuf:"bytes,2,opt,name=type_iD" json:"type_iD,omitempty"`
	// Unix time in seconds for the metric value (don't need nanos).
	Seconds int64 `protobuf:"varint,3,opt,name=seconds" json:"seconds,omitempty"`
	// The mean latency
	Mean int32 `protobuf:"varint,4,opt,name=mean" json:"mean,omitempty"`
	// The fiftieth percentile value.  Might be unknown (0)
	Fifty int32 `protobuf:"varint,5,opt,name=fifty" json:"fifty,omitempty"`
	// The ninetieth percentile value.  Might be unknown (0)
	Ninety int32 `protobuf:"varint,6,opt,name=ninety" json:"ninety,omitempty"`
	// The upper threshold for the metric to be good.
	Upper int32 `protobuf:"varint,7,opt,name=upper" json:"upper,omitempty"`
	// The lower threshold for the metric to be good.
	Lower int32 `protobuf:"varint,8,opt,name=lower" json:"lower,omitempty"`
}

func (m *DataLatencySummary) Reset()                    { *m = DataLatencySummary{} }
func (m *DataLatencySummary) String() string            { return proto.CompactTextString(m) }
func (*DataLatencySummary) ProtoMessage()               {}
func (*DataLatencySummary) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type DataLatencySummaryResult struct {
	Result []*DataLatencySummary `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *DataLatencySummaryResult) Reset()                    { *m = DataLatencySummaryResult{} }
func (m *DataLatencySummaryResult) String() string            { return proto.CompactTextString(m) }
func (*DataLatencySummaryResult) ProtoMessage()               {}
func (*DataLatencySummaryResult) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *DataLatencySummaryResult) GetResult() []*DataLatencySummary {
	if m != nil {
		return m.Result
	}
	return nil
}

type DataSite struct {
	// The siteID for the metric e.g., TAUP
	SiteID string `protobuf:"bytes,1,opt,name=site_iD" json:"site_iD,omitempty"`
	// The site latitude - not usually accurate enough for meta data
	Latitude float64 `protobuf:"fixed64,2,opt,name=latitude" json:"latitude,omitempty"`
	// The site longitude - not usually accurate enough for meta data
	Longitude float64 `protobuf:"fixed64,3,opt,name=longitude" json:"longitude,omitempty"`
}

func (m *DataSite) Reset()                    { *m = DataSite{} }
func (m *DataSite) String() string            { return proto.CompactTextString(m) }
func (*DataSite) ProtoMessage()               {}
func (*DataSite) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

type DataSiteResult struct {
	Result []*DataSite `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *DataSiteResult) Reset()                    { *m = DataSiteResult{} }
func (m *DataSiteResult) String() string            { return proto.CompactTextString(m) }
func (*DataSiteResult) ProtoMessage()               {}
func (*DataSiteResult) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *DataSiteResult) GetResult() []*DataSite {
	if m != nil {
		return m.Result
	}
	return nil
}

type DataLatencyTag struct {
	// The siteID for the latency e.g., TAUP
	SiteID string `protobuf:"bytes,1,opt,name=site_iD" json:"site_iD,omitempty"`
	// The typeID for the latency e.g., latency.gnss.1hz
	TypeID string `protobuf:"bytes,2,opt,name=type_iD" json:"type_iD,omitempty"`
	// The tag for the latency e.g., TAUP
	Tag string `protobuf:"bytes,3,opt,name=tag" json:"tag,omitempty"`
}

func (m *DataLatencyTag) Reset()                    { *m = DataLatencyTag{} }
func (m *DataLatencyTag) String() string            { return proto.CompactTextString(m) }
func (*DataLatencyTag) ProtoMessage()               {}
func (*DataLatencyTag) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

type DataLatencyTagResult struct {
	Result []*DataLatencyTag `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *DataLatencyTagResult) Reset()                    { *m = DataLatencyTagResult{} }
func (m *DataLatencyTagResult) String() string            { return proto.CompactTextString(m) }
func (*DataLatencyTagResult) ProtoMessage()               {}
func (*DataLatencyTagResult) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *DataLatencyTagResult) GetResult() []*DataLatencyTag {
	if m != nil {
		return m.Result
	}
	return nil
}

type DataLatencyThreshold struct {
	// The siteID for the latency e.g., TAUP
	SiteID string `protobuf:"bytes,1,opt,name=site_iD" json:"site_iD,omitempty"`
	// The typeID for the latency e.g., latency.gnss.1hz
	TypeID string `protobuf:"bytes,2,opt,name=type_iD" json:"type_iD,omitempty"`
	// The lower threshold for the latency to be good.
	Lower int32 `protobuf:"varint,3,opt,name=lower" json:"lower,omitempty"`
	// The upper threshold for the latency to be good.
	Upper int32 `protobuf:"varint,4,opt,name=upper" json:"upper,omitempty"`
}

func (m *DataLatencyThreshold) Reset()                    { *m = DataLatencyThreshold{} }
func (m *DataLatencyThreshold) String() string            { return proto.CompactTextString(m) }
func (*DataLatencyThreshold) ProtoMessage()               {}
func (*DataLatencyThreshold) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

type DataLatencyThresholdResult struct {
	Result []*DataLatencyThreshold `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *DataLatencyThresholdResult) Reset()                    { *m = DataLatencyThresholdResult{} }
func (m *DataLatencyThresholdResult) String() string            { return proto.CompactTextString(m) }
func (*DataLatencyThresholdResult) ProtoMessage()               {}
func (*DataLatencyThresholdResult) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *DataLatencyThresholdResult) GetResult() []*DataLatencyThreshold {
	if m != nil {
		return m.Result
	}
	return nil
}

type DataType struct {
	// The TypeID in the table data.type
	TypeID string `protobuf:"bytes,1,opt,name=type_iD" json:"type_iD,omitempty"`
}

func (m *DataType) Reset()                    { *m = DataType{} }
func (m *DataType) String() string            { return proto.CompactTextString(m) }
func (*DataType) ProtoMessage()               {}
func (*DataType) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

type DataTypeResult struct {
	Result []*DataType `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *DataTypeResult) Reset()                    { *m = DataTypeResult{} }
func (m *DataTypeResult) String() string            { return proto.CompactTextString(m) }
func (*DataTypeResult) ProtoMessage()               {}
func (*DataTypeResult) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *DataTypeResult) GetResult() []*DataType {
	if m != nil {
		return m.Result
	}
	return nil
}

// DataCompletenessSummary is metrics to let us determine if all the data had arrived.
// The "completenss" value is derived from:
//    {count in a period of time (no less than 5 minutes)} / { expected count im a period of time }
// For example, a site(type) expects 300 counts in 5 minutes (1hz),
//    but got 270 counts for the latest 5 minutes then its latest completeness will be 0.9 .
type DataCompletenessSummary struct {
	// The siteID for the completeness e.g., TAUP
	SiteID string `protobuf:"bytes,1,opt,name=site_iD" json:"site_iD,omitempty"`
	// The typeID for the completeness e.g., gnss.1hz
	TypeID string `protobuf:"bytes,2,opt,name=type_iD" json:"type_iD,omitempty"`
	// Unix time in seconds for the metric value (don't need nanos).
	Seconds int64 `protobuf:"varint,3,opt,name=seconds" json:"seconds,omitempty"`
	// The completeness for a given period of time
	Completeness float32 `protobuf:"fixed32,4,opt,name=completeness" json:"completeness,omitempty"`
}

func (m *DataCompletenessSummary) Reset()                    { *m = DataCompletenessSummary{} }
func (m *DataCompletenessSummary) String() string            { return proto.CompactTextString(m) }
func (*DataCompletenessSummary) ProtoMessage()               {}
func (*DataCompletenessSummary) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{10} }

type DataCompletenessSummaryResult struct {
	Result []*DataCompletenessSummary `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *DataCompletenessSummaryResult) Reset()                    { *m = DataCompletenessSummaryResult{} }
func (m *DataCompletenessSummaryResult) String() string            { return proto.CompactTextString(m) }
func (*DataCompletenessSummaryResult) ProtoMessage()               {}
func (*DataCompletenessSummaryResult) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{11} }

func (m *DataCompletenessSummaryResult) GetResult() []*DataCompletenessSummary {
	if m != nil {
		return m.Result
	}
	return nil
}

type DataCompletenessTag struct {
	// The siteID for the latency e.g., TAUP
	SiteID string `protobuf:"bytes,1,opt,name=site_iD" json:"site_iD,omitempty"`
	// The typeID for the latency e.g., gnss.1hz
	TypeID string `protobuf:"bytes,2,opt,name=type_iD" json:"type_iD,omitempty"`
	// The tag for the latency e.g., TAUP
	Tag string `protobuf:"bytes,3,opt,name=tag" json:"tag,omitempty"`
}

func (m *DataCompletenessTag) Reset()                    { *m = DataCompletenessTag{} }
func (m *DataCompletenessTag) String() string            { return proto.CompactTextString(m) }
func (*DataCompletenessTag) ProtoMessage()               {}
func (*DataCompletenessTag) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{12} }

type DataCompletenessTagResult struct {
	Result []*DataCompletenessTag `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
}

func (m *DataCompletenessTagResult) Reset()                    { *m = DataCompletenessTagResult{} }
func (m *DataCompletenessTagResult) String() string            { return proto.CompactTextString(m) }
func (*DataCompletenessTagResult) ProtoMessage()               {}
func (*DataCompletenessTagResult) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{13} }

func (m *DataCompletenessTagResult) GetResult() []*DataCompletenessTag {
	if m != nil {
		return m.Result
	}
	return nil
}

func init() {
	proto.RegisterType((*DataLatencySummary)(nil), "mtrpb.DataLatencySummary")
	proto.RegisterType((*DataLatencySummaryResult)(nil), "mtrpb.DataLatencySummaryResult")
	proto.RegisterType((*DataSite)(nil), "mtrpb.DataSite")
	proto.RegisterType((*DataSiteResult)(nil), "mtrpb.DataSiteResult")
	proto.RegisterType((*DataLatencyTag)(nil), "mtrpb.DataLatencyTag")
	proto.RegisterType((*DataLatencyTagResult)(nil), "mtrpb.DataLatencyTagResult")
	proto.RegisterType((*DataLatencyThreshold)(nil), "mtrpb.DataLatencyThreshold")
	proto.RegisterType((*DataLatencyThresholdResult)(nil), "mtrpb.DataLatencyThresholdResult")
	proto.RegisterType((*DataType)(nil), "mtrpb.DataType")
	proto.RegisterType((*DataTypeResult)(nil), "mtrpb.DataTypeResult")
	proto.RegisterType((*DataCompletenessSummary)(nil), "mtrpb.DataCompletenessSummary")
	proto.RegisterType((*DataCompletenessSummaryResult)(nil), "mtrpb.DataCompletenessSummaryResult")
	proto.RegisterType((*DataCompletenessTag)(nil), "mtrpb.DataCompletenessTag")
	proto.RegisterType((*DataCompletenessTagResult)(nil), "mtrpb.DataCompletenessTagResult")
}

var fileDescriptor1 = []byte{
	// 413 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x94, 0xdf, 0x4b, 0xeb, 0x30,
	0x14, 0xc7, 0xe9, 0xba, 0x76, 0xdb, 0xd9, 0xee, 0x76, 0x6f, 0xef, 0x2e, 0xb7, 0xdb, 0xf0, 0x07,
	0x01, 0x61, 0x2a, 0x14, 0xd4, 0x67, 0x51, 0x74, 0x22, 0x82, 0x20, 0xb8, 0xe1, 0x83, 0x2f, 0x92,
	0xad, 0xd9, 0x56, 0xe8, 0x2f, 0xda, 0x14, 0xe9, 0xbf, 0xe1, 0x5f, 0x6c, 0x92, 0xb6, 0xd2, 0xb5,
	0x1d, 0x0c, 0x7d, 0xcb, 0x39, 0xc9, 0x39, 0xdf, 0xcf, 0x37, 0x27, 0x04, 0xc0, 0xc4, 0x14, 0x1b,
	0x7e, 0xe0, 0x51, 0x4f, 0x53, 0x1c, 0x1a, 0xf8, 0x73, 0xf4, 0x21, 0x81, 0x36, 0x61, 0xd9, 0x47,
	0x4c, 0x89, 0xbb, 0x88, 0xa7, 0x91, 0xe3, 0xe0, 0x20, 0xd6, 0x7a, 0xd0, 0x08, 0x2d, 0x4a, 0xde,
	0xac, 0x89, 0x2e, 0x1d, 0x4a, 0xe3, 0x16, 0x4f, 0xd0, 0xd8, 0x17, 0x89, 0x5a, 0x96, 0x08, 0xc9,
	0xc2, 0x73, 0xcd, 0x50, 0x97, 0x59, 0x42, 0xd6, 0x3a, 0x50, 0x77, 0x08, 0x76, 0xf5, 0x3a, 0x8b,
	0x14, 0xed, 0x17, 0x28, 0x4b, 0x6b, 0x49, 0x63, 0x5d, 0x11, 0x61, 0x17, 0x54, 0xd7, 0x72, 0x09,
	0x8b, 0xd5, 0x6c, 0x3b, 0xf2, 0x7d, 0x12, 0xe8, 0x8d, 0x2c, 0xb4, 0xbd, 0x77, 0x16, 0x36, 0x79,
	0x88, 0xee, 0x40, 0x2f, 0x33, 0x3d, 0x93, 0x30, 0xb2, 0xa9, 0x76, 0x0c, 0x6a, 0x20, 0x56, 0x0c,
	0x4c, 0x1e, 0xb7, 0xcf, 0x07, 0x86, 0x30, 0x62, 0x94, 0x0b, 0xd0, 0x35, 0x34, 0x79, 0x76, 0xca,
	0x8c, 0x94, 0x0d, 0xfd, 0x86, 0xa6, 0x8d, 0xa9, 0x45, 0x23, 0x93, 0x08, 0x47, 0x92, 0xf6, 0x07,
	0x5a, 0xb6, 0xe7, 0xae, 0x92, 0x14, 0xf7, 0x24, 0xa1, 0x33, 0xe8, 0x66, 0x1d, 0x52, 0xf9, 0x83,
	0x82, 0x7c, 0x2f, 0x27, 0xcf, 0x8f, 0xa1, 0xab, 0xa4, 0x24, 0x45, 0x99, 0xe1, 0xd5, 0x0e, 0x77,
	0xd9, 0x06, 0x99, 0xe2, 0x95, 0xd0, 0x6c, 0xa1, 0x4b, 0xe8, 0x6f, 0x36, 0x48, 0x95, 0x8f, 0x0a,
	0xca, 0xff, 0xca, 0xc6, 0xd9, 0x61, 0xf4, 0xb2, 0x59, 0xbe, 0x66, 0x35, 0x6b, 0xcf, 0x36, 0x77,
	0xa0, 0xf8, 0x1a, 0x82, 0xbc, 0x39, 0x22, 0x31, 0x50, 0xf4, 0x00, 0xc3, 0xaa, 0xbe, 0x29, 0xdc,
	0x69, 0x01, 0x6e, 0x54, 0x01, 0x97, 0x95, 0xa0, 0x51, 0x32, 0x97, 0x19, 0x53, 0xcf, 0x53, 0x08,
	0xac, 0xec, 0xca, 0xf9, 0xe6, 0x0e, 0x57, 0xce, 0x8f, 0xa1, 0x39, 0xfc, 0xe7, 0xeb, 0x5b, 0xcf,
	0xf1, 0x6d, 0xc2, 0xb4, 0x48, 0x18, 0xfe, 0xe0, 0x1d, 0xf7, 0xa1, 0xb3, 0xc8, 0x75, 0x12, 0xf6,
	0x6b, 0xe8, 0x09, 0xf6, 0xb6, 0x68, 0xa4, 0x94, 0x46, 0x81, 0x72, 0x3f, 0x47, 0x59, 0x51, 0x85,
	0x26, 0xf0, 0xb7, 0xb8, 0xf5, 0x8d, 0xc7, 0x72, 0x0f, 0x83, 0x8a, 0x2e, 0x29, 0xd2, 0x49, 0x01,
	0x69, 0xb8, 0x05, 0x89, 0x55, 0xdc, 0x34, 0x5e, 0x93, 0x0f, 0x61, 0xae, 0x8a, 0xef, 0xe1, 0xe2,
	0x33, 0x00, 0x00, 0xff, 0xff, 0xa4, 0x4f, 0xd5, 0xd8, 0x2c, 0x04, 0x00, 0x00,
}
